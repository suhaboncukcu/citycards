{"version":3,"file":"/packages/matteodem:easy-search.js","sources":["matteodem:easy-search/lib/easy-search-common.js","matteodem:easy-search/lib/easy-search-convenience.js","matteodem:easy-search/lib/searchers/mongo.js","matteodem:easy-search/lib/easy-search-server.js","matteodem:easy-search/lib/searchers/elastic-search.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,e;;AAEA,e;AACA,c;AACA,2C;AACA,sB;AACA,yB;AACA,iB;AACA,mB;AACA,0B;AACA,wB;AACA,mB;AACA,4B;AACA,kC;AACA,uD;AACA,S;;AAEA,kB;AACA,Q;AACA,6B;AACA,wD;;AAEA,kB;AACA,2B;AACA,S;;AAEA,iB;AACA,Q;AACA,4C;AACA,uB;AACA,Q;AACA,S;AACA,yD;AACA,4D;AACA,Q;AACA,qC;AACA,yB;AACA,S;AACA,yC;AACA,oE;AACA,O;AACA,M;;AAEA,8C;;AAEA,yB;AACA,yC;AACA,0D;AACA,oB;AACA,yB;AACA,4B;;AAEA,0B;;AAEA,yC;AACA,qC;AACA,8D;AACA,sE;AACA,wC;;AAEA,8E;;AAEA,6F;;AAEA,yC;AACA,+C;AACA,0D;AACA,sD;AACA,0C;AACA,S;;AAEA,2C;AACA,uB;AACA,6E;AACA,oB;AACA,mC;AACA,gC;AACA,kE;AACA,c;AACA,qC;AACA,oE;AACA,c;AACA,qC;AACA,+D;AACA,a;AACA,W;AACA,U;;AAEA,6B;AACA,c;AACA,kB;AACA,O;AACA,O;;AAEA,2D;AACA,6C;AACA,O;AACA,G;;AAEA,wB;AACA,O;AACA,6D;AACA,+B;AACA,8B;AACA,6B;AACA,O;AACA,wD;AACA,gC;AACA,kC;AACA,qD;AACA,M;;AAEA,O;AACA,gE;AACA,+B;AACA,8B;AACA,0B;AACA,O;AACA,2D;AACA,8C;AACA,kC;AACA,oC;AACA,O;;AAEA,wD;AACA,M;AACA,G;;;AAGA,K;AACA,kF;AACA,I;AACA,mE;AACA,yE;AACA,yE;AACA,I;AACA,K;AACA,iB;;AAEA,U;AACA,O;AACA,iC;AACA,M;AACA,gC;AACA,O;AACA,qC;AACA,gB;AACA,M;AACA,O;AACA,6B;AACA,M;AACA,8B;AACA,2B;AACA,O;AACA,sC;AACA,2B;;AAEA,mD;AACA,+B;AACA,wD;AACA,6B;AACA,O;AACA,M;AACA,O;AACA,6B;AACA,M;AACA,2B;AACA,8B;AACA,O;AACA,oD;AACA,6C;AACA,6B;;AAEA,0B;AACA,iF;AACA,iE;;AAEA,8B;;AAEA,+B;AACA,uB;AACA,uG;AACA,kB;AACA,U;AACA,O;;AAEA,mE;AACA,8C;AACA,O;;AAEA,wF;AACA,M;AACA,O;AACA,wB;AACA,M;AACA,wD;AACA,iE;AACA,sE;AACA,oE;AACA,O;AACA,iE;AACA,kB;AACA,8B;AACA,iC;;AAEA,0B;AACA,kC;AACA,6B;AACA,gD;;AAEA,2D;AACA,wF;AACA,O;;AAEA,+G;;AAEA,0C;AACA,M;AACA,O;AACA,+C;AACA,M;AACA,2B;AACA,uB;AACA,kB;AACA,O;AACA,kC;AACA,2B;AACA,M;AACA,O;AACA,wC;AACA,O;AACA,gC;AACA,qB;AACA,M;AACA,O;AACA,mC;AACA,M;AACA,2B;AACA,uB;AACA,kB;AACA,O;AACA,qC;AACA,6B;AACA,M;AACA,O;AACA,8B;AACA,O;AACA,kC;AACA,uB;AACA,M;AACA,O;AACA,8D;AACA,M;AACA,oC;AACA,sB;AACA,O;AACA,gD;AACA,0D;;AAEA,wC;AACA,oD;AACA,S;AACA,M;AACA,O;AACA,4D;AACA,kE;AACA,gD;AACA,M;AACA,mE;AACA,wE;AACA,mE;AACA,kF;AACA,sE;AACA,uD;AACA,O;AACA,gD;AACA,yB;AACA,sC;AACA,iD;;AAEA,+B;AACA,M;AACA,O;AACA,uF;AACA,M;AACA,kE;AACA,O;AACA,6C;AACA,4C;AACA,+D;AACA,K;AACA,I;AACA,K;;;;;;;;;;;;;;;;;;;ACrSA,yE;AACA,6B;AACA,iB;AACA,G;;AAEA,8D;AACA,wB;AACA,oB;AACA,M;AACA,E;;AAEA,sB;AACA,6C;AACA,W;AACA,sB;;AAEA,0D;AACA,gB;AACA,K;;AAEA,mG;;AAEA,0E;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;;ACxBA,e;AACA,K;AACA,2B;AACA,I;AACA,gB;AACA,mB;AACA,oB;AACA,K;AACA,oD;AACA,K;AACA,I;AACA,kD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,+B;AACA,sB;AACA,K;AACA,+D;AACA,e;AACA,c;AACA,e;AACA,oB;AACA,wC;;AAEA,6B;AACA,a;AACA,K;;AAEA,wC;;AAEA,yE;AACA,kD;;AAEA,oB;AACA,uC;AACA,K;;AAEA,qB;AACA,qC;AACA,M;;AAEA,+B;AACA,kD;AACA,K;;AAEA,uB;AACA,wC;AACA,K;;AAEA,4D;;AAEA,e;AACA,yD;AACA,8B;AACA,M;;AAEA,iC;AACA,wB;AACA,K;;AAEA,mB;AACA,I;AACA,K;AACA,8D;AACA,I;AACA,4B;AACA,iC;AACA,sB;AACA,K;AACA,qD;AACA,mB;AACA,oB;AACA,4B;AACA,mF;;AAEA,4B;AACA,uC;AACA,sB;AACA,K;;AAEA,oC;AACA,+E;AACA,gD;AACA,K;;AAEA,yB;AACA,yB;;AAEA,0C;AACA,sB;;AAEA,qC;AACA,iD;AACA,4C;AACA,+C;AACA,O;;AAEA,uC;AACA,O;;AAEA,oB;AACA,I;AACA,K;AACA,sE;AACA,I;AACA,4B;AACA,kB;AACA,K;AACA,sC;AACA,yB;AACA,G;AACA,E;;AAEA,sB;AACA,kD;AACA,6B;AACA,iD;AACA,C;;;;;;;;;;;;;;;;;;;;ACvHA,a;AACA,iD;;AAEA,+B;AACA,yB;AACA,E;;AAEA,G;AACA,0C;AACA,E;AACA,4B;AACA,G;AACA,0C;AACA,yC;AACA,6B;AACA,8D;AACA,sE;AACA,G;;AAEA,sB;AACA,E;;AAEA,G;AACA,8B;AACA,yF;AACA,E;AACA,iC;AACA,G;AACA,iD;AACA,kC;AACA,E;;AAEA,gB;AACA,K;AACA,oD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,K;AACA,sD;AACA,wB;AACA,gC;AACA,2B;AACA,0D;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC9CA,a;;AAEA,0C;AACA,+C;;AAEA,G;AACA,wC;AACA,E;AACA,0D;AACA,mB;AACA,G;AACA,2B;AACA,kB;;AAEA,qC;AACA,yF;AACA,K;;AAEA,gB;AACA,C;;AAEA,6C;AACA,K;AACA,2C;AACA,I;AACA,yB;AACA,wB;AACA,uB;AACA,K;AACA,6C;AACA,2C;;AAEA,mB;AACA,0C;AACA,iC;AACA,uB;AACA,c;AACA,gB;AACA,6B;AACA,gB;AACA,oD;AACA,yB;AACA,O;;AAEA,oC;AACA,gF;AACA,kD;AACA,O;AACA,O;AACA,I;AACA,K;AACA,8D;AACA,I;AACA,yB;AACA,4B;AACA,K;AACA,kD;AACA,6B;AACA,yC;;AAEA,gE;AACA,uF;AACA,K;;AAEA,8B;;AAEA,8C;AACA,oC;AACA,kE;AACA,Q;AACA,sC;AACA,2D;AACA,0F;AACA,Q;AACA,8B;AACA,+C;AACA,sB;AACA,0B;AACA,gB;AACA,uC;AACA,6B;AACA,qE;AACA,W;AACA,W;AACA,O;AACA,O;AACA,I;AACA,K;AACA,0D;AACA,I;AACA,yB;AACA,qB;AACA,K;AACA,uC;AACA,sD;;AAEA,8D;AACA,4B;;AAEA,gC;AACA,yB;AACA,O;;AAEA,iD;AACA,8B;AACA,O;;AAEA,Y;AACA,0B;AACA,+B;AACA,M;AACA,I;AACA,K;AACA,wD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,+B;AACA,iB;AACA,K;AACA,+D;AACA,gB;AACA,kB;AACA,yB;AACA,wC;;AAEA,6B;AACA,a;AACA,K;;AAEA,e;AACA,kD;AACA,M;;AAEA,yB;AACA,uC;AACA,K;;AAEA,4B;AACA,8C;AACA,K;;AAEA,+B;AACA,wD;AACA,yC;AACA,O;;AAEA,4C;AACA,K;;AAEA,2C;AACA,iD;AACA,oC;AACA,K;;AAEA,8B;;AAEA,yC;AACA,qE;AACA,a;AACA,K;;AAEA,+C;AACA,2C;AACA,mB;AACA,qB;AACA,2B;AACA,wB;AACA,+B;AACA,kB;AACA,qD;AACA,2B;AACA,e;AACA,O;;AAEA,mC;AACA,0C;AACA,O;;AAEA,0B;AACA,O;;AAEA,sB;AACA,I;AACA,K;AACA,gE;AACA,I;AACA,4B;AACA,iC;AACA,kB;AACA,K;AACA,qD;AACA,Y;AACA,2B;AACA,iC;AACA,kC;AACA,O;AACA,M;AACA,I;AACA,K;AACA,gE;AACA,I;AACA,4B;AACA,kB;AACA,K;AACA,sC;AACA,yB;AACA,G;AACA,G;;AAEA,2B;AACA,yC","sourcesContent":["EasySearch = (function () {\n  'use strict';\n\n  var ESCounts,\n    Searchers,\n    indexes = {/** @see defaultOptions */},\n    defaultOptions = {\n      'format' : 'mongo',\n      'skip' : 0,\n      'limit' : 10,\n      'use' : 'minimongo',\n      'reactive' : true,\n      'props' : {},\n      'sort' : function () {\n        if (Searchers[this.use]) {\n          return Searchers[this.use].defaultSort(this);\n        }\n\n        return {};\n      },\n      'count' : function () {\n        var doc = ESCounts.findOne({ _id : this.name });\n\n        if (doc) {\n          return doc.count;\n        }\n\n        return 0;\n      },\n      'changeResults' : function (results) {\n        return results;\n      },\n      /**\n       * When using elastic-search it's the query object,\n       * while using with mongo-db it's the selector object.\n       *\n       * @param {String} searchString\n       * @return {Object}\n       */\n      'query' : function (searchString) {\n        return Searchers[this.use].defaultQuery(this, searchString);\n      }\n    };\n\n  ESCounts = new Mongo.Collection('esCounts');\n\n  /** Helper Functions */\n  function setUpPublication(name, opts) {\n    Meteor.publish(name + '/easySearch', function (conf) {\n      var resultSet,\n        resultArray = [],\n        publishScope = this;\n\n      check(conf, Object);\n\n      // TODO: sanity check each property\n      indexes[name].skip = conf.skip;\n      indexes[name].limit = conf.limit || indexes[name].limit;\n      indexes[name].props = _.extend(indexes[name].props, conf.props);\n      indexes[name].publishScope = this;\n\n      resultSet = Searchers[opts.use].search(name, conf.value, indexes[name]);\n\n      ESCounts.update({ _id: name }, { $set: { count: resultSet.total } }, { upsert: true });\n\n      if (resultSet.results.length > 0) {\n        if (_.isObject(resultSet.results[0])) {\n          resultArray = _.pluck(resultSet.results, '_id');\n        } else if (_.isString(resultSet.results[0])) {\n          resultArray = resultSet.results;\n        }\n\n        // properly observe the collection!\n        opts.collection\n          .find({ _id: { $in: resultArray } }, { sort: indexes[name].sort()})\n          .observe({\n            added: function (doc) {\n              doc._index = name;\n              publishScope.added('esSearchResults', doc._id, doc);\n            },\n            changed: function (doc) {\n              publishScope.changed('esSearchResults', doc._id, doc);\n            },\n            removed: function (doc) {\n              publishScope.removed('esSearchResults', doc._id);\n            }\n          }\n        );\n\n        publishScope.ready();\n      } else {\n        return [];\n      }\n    });\n\n    Meteor.publish(name + '/easySearchCount', function () {\n      return ESCounts.find({ '_id' : name });\n    });\n  }\n\n  if (Meteor.isClient) {\n    /**\n     * find method to let users interact with search results.\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {MongoCursor}\n     */\n    defaultOptions.find = function (selector, options) {\n      selector = selector || {};\n      selector._index = this.name;\n      return ESSearchResults.find(selector, options);\n    };\n\n    /**\n     * findOne method to let users interact with search results.\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {Document}\n     */\n    defaultOptions.findOne = function (selector, options) {\n      if (_.isObject(selector) || !selector) {\n        selector = selector || {};\n        selector._index = this.name;\n      }\n\n      return ESSearchResults.findOne(selector, options);\n    };\n  }\n\n\n  /**\n   * Searchers contains all engines that can be used to search content, until now:\n   *\n   * minimongo (client): Client side collection for reactive search\n   * elastic-search (server): Elastic search server to search with (fast)\n   * mongo-db (server): MongoDB on the server to search (more convenient)\n   *\n   */\n  Searchers = {};\n\n  return {\n    /**\n     * Placeholder config method.\n     *\n     * @param {Object} newConfig\n     */\n    'config' : function (newConfig) {\n      return {};\n    },\n    /**\n     * Simple logging method.\n     *\n     * @param {String} message\n     * @param {String} type\n     */\n    'log' : function (message, type) {\n      type = type || 'log';\n\n      if (console && _.isFunction(console[type])) {\n        console[type](message);\n      } else if (console && _.isFunction(console.log)) {\n        console.log(message);\n      }\n    },\n    /**\n     * Create a search index.\n     *\n     * @param {String} name\n     * @param {Object} options\n     */\n    'createSearchIndex' : function (name, options) {\n      check(name, Match.OneOf(String, null));\n      check(options, Object);\n\n      options.name = name;\n      options.field = _.isArray(options.field) ? options.field : [options.field];\n      indexes[name] = _.extend(_.clone(defaultOptions), options);\n\n      options = indexes[name];\n\n      if (options.permission) {\n        EasySearch.log(\n            'permission property is now deprecated! Return false inside a custom query method instead',\n            'warn'\n        );\n      }\n\n      if (Meteor.isServer && EasySearch._usesSubscriptions(name)) {\n        setUpPublication(name, indexes[name]);\n      }\n\n      Searchers[options.use] && Searchers[options.use].createSearchIndex(name, options);\n    },\n    /**\n     * Perform a search.\n     *\n     * @param {String} name             the search index\n     * @param {String} searchString     the string to be searched\n     * @param {Object} options          defined with createSearchIndex\n     * @param {Function} callback       optional callback to be used\n     */\n    'search' : function (name, searchString, options, callback) {\n      var results,\n        index = indexes[name],\n        searcherType = index.use;\n\n      check(name, String);\n      check(searchString, String);\n      check(options, Object);\n      check(callback, Match.Optional(Function));\n\n      if (\"undefined\" === typeof Searchers[searcherType]) {\n        throw new Meteor.Error(500, \"Couldnt search with type: '\" + searcherType + \"'\");\n      }\n\n      results = Searchers[searcherType].search(name, searchString, _.extend(indexes[name], options), callback);\n\n      return index.changeResults(results);\n    },\n    /**\n     * Retrieve a specific index configuration.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getIndex' : function (name) {\n      return indexes[name];\n    },\n    /**\n     * Retrieve all index configurations\n     */\n    'getIndexes' : function () {\n      return indexes;\n    },\n    /**\n     * Retrieve a specific Seacher.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getSearcher' : function (name) {\n      return Searchers[name];\n    },\n    /**\n     * Retrieve all Searchers.\n     */\n    'getSearchers' : function () {\n      return Searchers;\n    },\n    /**\n     * Loop through the indexes and provide the configuration.\n     *\n     * @param {Array|String} indexes\n     * @param callback\n     */\n    'eachIndex' : function (indexes, callback) {\n      indexes = !_.isArray(indexes) ? [indexes] : indexes;\n\n      _.each(indexes, function (index) {\n        callback(index, EasySearch.getIndex(index));\n      });\n    },\n    /**\n     * Makes it possible to override or extend the different\n     * types of search to use with EasySearch (the \"use\" property)\n     * when using EasySearch.createSearchIndex()\n     *\n     * @param {String} key      Type, e.g. mongo-db, elastic-search\n     * @param {Object} methods  Methods to be used, only 2 are required:\n     *                          - createSearchIndex (name, options)\n     *                          - search (name, searchString, [options, callback])\n     *                          - defaultQuery (options, searchString)\n     *                          - defaultSort (options)\n     */\n    'createSearcher' : function (key, methods) {\n      check(key, String);\n      check(methods.search, Function);\n      check(methods.createSearchIndex, Function);\n\n      Searchers[key] = methods;\n    },\n    /**\n     * Simple helper to check if searcher uses server side subscriptions for searching.\n     *\n     * @param {String} index Index name to check configuration for\n     */\n    '_usesSubscriptions' : function (index) {\n      var conf = EasySearch.getIndex(index);\n      return conf && conf.reactive && conf.use !== 'minimongo';\n    }\n  };\n})();\n","Meteor.Collection.prototype.initEasySearch = function (fields, options) {\n  if (!_.isObject(options)) {\n    options = {};\n  }\n\n  EasySearch.createSearchIndex(this._name, _.extend(options, {\n    'collection' : this,\n    'field' : fields\n  }));\n};\n\nif (Meteor.isClient) {\n  jQuery.fn.esAutosuggestData = function () {\n    var id,\n      input = $(this);\n\n    if (input.prop(\"tagName\").toUpperCase() !== 'INPUT') {\n      return [];\n    }\n\n    id = EasySearch.Components.generateId(input.parent().data('index'), input.parent().data('id'));\n\n    return EasySearch.Components.Variables.get(id, 'autosuggestSelected');\n  }\n}\n\n","var methods = {\n  /**\n   * Set up a search index.\n   *\n   * @param name\n   * @param options\n   * @returns {void}\n   */\n  'createSearchIndex' : function (name, options) {},\n  /**\n   *\n   * Perform a really simple search with mongo db.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var cursor,\n      results,\n      selector,\n      cursorOptions,\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    options.limit = options.limit || 10;\n\n    // if several, fields do an $or search, otherwise only over the field\n    selector = index.query(searchString, options);\n\n    if (!selector) {\n      return { total: 0, results: [] };\n    }\n\n    cursorOptions = {\n      sort : index.sort(searchString)\n    };\n\n    if (options.returnFields) {\n      cursorOptions.fields = options.returnFields;\n    }\n\n    if (options.skip) {\n      cursorOptions.skip = options.skip;\n    }\n\n    cursor = index.collection.find(selector, cursorOptions);\n\n    results = {\n      'results' : _.first(cursor.fetch(), options.limit),\n      'total' : cursor.count()\n    };\n\n    if (_.isFunction(callback)) {\n      callback(results);\n    }\n\n    return results;\n  },\n  /**\n   * The default mongo-db query - selector used for searching.\n   *\n   * @param {Object} options\n   * @param {String} searchString\n   * @returns {Object}\n   */\n  'defaultQuery' : function (options, searchString) {\n    var orSelector,\n      selector = {},\n      field = options.field,\n      stringSelector = { '$regex' : '.*' + searchString + '.*', '$options' : 'i' };\n\n    if (_.isString(field)) {\n      selector[field] = stringSelector;\n      return selector;\n    }\n\n    // Convert numbers if configured\n    if (options.convertNumbers && parseInt(searchString, 10) == searchString) {\n      searchString = parseInt(searchString, 10);\n    }\n\n    // Should be an array\n    selector['$or'] = [];\n\n    _.each(field, function (fieldString) {\n      orSelector = {};\n\n      if (_.isString(searchString)) {\n        orSelector[fieldString] = stringSelector;\n      } else if (_.isNumber(searchString)) {\n        orSelector[fieldString] = searchString;\n      }\n\n      selector['$or'].push(orSelector);\n    });\n\n    return selector;\n  },\n  /**\n   * The default mongo-db sorting method used for sorting the results.\n   *\n   * @param {Object} options\n   * @return array\n   */\n  'defaultSort' : function (options) {\n    return options.field;\n  }\n};\n\nif (Meteor.isClient) {\n  EasySearch.createSearcher('minimongo', methods);\n} else if (Meteor.isServer) {\n  EasySearch.createSearcher('mongo-db', methods);\n}\n\n","'use strict';\nvar ElasticSearch = Npm.require('elasticsearch');\n\nEasySearch._esDefaultConfig = {\n  host : 'localhost:9200'\n};\n\n/**\n * Override the config for Elastic Search.\n *\n * @param {object} newConfig\n */\nEasySearch.config = function (newConfig) {\n  if (\"undefined\" !== typeof newConfig) {\n    check(newConfig, Object);\n    this._config = _.extend(this._esDefaultConfig, newConfig);\n    this.ElasticSearchClient = new ElasticSearch.Client(this._config);\n  }\n\n  return this._config;\n};\n\n/**\n * Get the ElasticSearchClient\n * @see http://www.elasticsearch.org/guide/en/elasticsearch/client/javascript-api/current\n *\n * @return {ElasticSearch.Client}\n */\nEasySearch.getElasticSearchClient = function () {\n  return this.ElasticSearchClient;\n};\n\nMeteor.methods({\n  /**\n   * Make server side search possible on the client.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   */\n  easySearch: function (name, searchString, options) {\n    check(name, String);\n    check(searchString, String);\n    check(options, Object);\n    return EasySearch.search(name, searchString, options);\n  }\n});\n","'use strict';\n\nvar Future = Npm.require('fibers/future'),\n  ElasticSearch = Npm.require('elasticsearch');\n\n/**\n * Return Elastic Search indexable data.\n *\n * @param {Object} doc the document to get the values from\n * @return {Object}\n */\nfunction getESFields(doc) {\n  var newDoc = {};\n\n  _.each(doc, function (value, key) {\n    newDoc[key] = _.isObject(value) && !_.isArray(value) ? JSON.stringify(value) : value;\n  });\n\n  return newDoc;\n}\n\nEasySearch.createSearcher('elastic-search', {\n  /**\n   * Write a document to a specified index.\n   *\n   * @param {String} name\n   * @param {Object} doc\n   * @param {String} id\n   */\n  'writeToIndex' : function (name, doc, id) {\n    var config = EasySearch.config() || {};\n\n    // add to index\n    EasySearch.ElasticSearchClient.index({\n      index : name.toLowerCase(),\n      type : 'default',\n      id : id,\n      body : doc\n    }, function (err, data) {\n      if (err) {\n        console.log('Had error adding a document!');\n        console.log(err);\n      }\n\n      if (config.debug && console) {\n        console.log('EasySearch: Added / Replaced document to Elastic Search:');\n        console.log('EasySearch: ' + data + \"\\n\");\n      }\n    });\n  },\n  /**\n   * Setup some observers on the mongo db collection provided.\n   *\n   * @param {String} name\n   * @param {Object} options\n   */\n  'createSearchIndex' : function (name, options) {\n    var searcherScope = this,\n      config = EasySearch.config() || {};\n\n    if (\"undefined\" === typeof EasySearch.ElasticSearchClient) {\n      EasySearch.ElasticSearchClient = new ElasticSearch.Client(this._esDefaultConfig);\n    }\n\n    name = name.toLowerCase();\n\n    options.collection.find().observeChanges({\n      added: function (id, fields) {\n        searcherScope.writeToIndex(name, getESFields(fields), id);\n      },\n      changed: function (id, fields) {\n        // Overwrites the current document with the new doc\n        searcherScope.writeToIndex(name, getESFields(options.collection.findOne(id)), id);\n      },\n      removed: function (id) {\n        EasySearch.ElasticSearchClient.delete({\n          index: name,\n          type: 'default',\n          id: id\n        }, function (error, response) {\n          if (config.debug) {\n            console.log('Removed document with id ( ' +  id + ' )!');\n          }\n        });\n      }\n    });\n  },\n  /**\n   * Get the data out of the JSON elastic search response.\n   *\n   * @param {Object} data\n   * @returns {Array}\n   */\n  'extractJSONData' : function (data) {\n    data = _.isString(data) ? JSON.parse(data) : data;\n\n    var results = _.map(data.hits.hits, function (resultSet) {\n      var field = '_source';\n\n      if (resultSet['fields']) {\n        field = 'fields';\n      }\n\n      resultSet[field]['_id'] = resultSet['_id'];\n      return resultSet[field];\n    });\n\n    return {\n      'results' : results,\n      'total' : data.hits.total\n    };\n  },\n  /**\n   * Perform a search with Elastic Search, using fibers.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {*}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var bodyObj,\n      that = this,\n      fut = new Future(),\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    bodyObj = {\n      \"query\" : index.query(searchString, options)\n    };\n\n    if (!bodyObj.query) {\n      return { total: 0, results: [] };\n    }\n\n    if (!options.reactive) {\n      bodyObj.sort = index.sort(searchString);\n    }\n\n    if (options.returnFields) {\n      if (options.returnFields.indexOf('_id') === -1 ) {\n        options.returnFields.push('_id');\n      }\n\n      bodyObj.fields = options.returnFields;\n    }\n\n    // Modify Elastic Search body if wished\n    if (index.body && _.isFunction(index.body)) {\n      bodyObj = index.body(bodyObj);\n    }\n\n    name = name.toLowerCase();\n\n    if (\"function\" === typeof callback) {\n      EasySearch.ElasticSearchClient.search(name, bodyObj, callback);\n      return;\n    }\n\n    // Most likely client call, return data set\n    EasySearch.ElasticSearchClient.search({\n      index : name,\n      body : bodyObj,\n      size : options.limit,\n      from: options.skip\n    }, function (error, data) {\n      if (error) {\n        console.log('Had an error while searching!');\n        console.log(error);\n        return;\n      }\n\n      if (\"raw\" !== index.format) {\n        data = that.extractJSONData(data);\n      }\n\n      fut['return'](data);\n    });\n\n    return fut.wait();\n  },\n  /**\n   * The default ES query object used for searching the results.\n   *\n   * @param {Object} options\n   * @param {String} searchString\n   * @return array\n   */\n  'defaultQuery' : function (options, searchString) {\n    return {\n      \"fuzzy_like_this\" : {\n        \"fields\" : options.field,\n        \"like_text\" : searchString\n      }\n    };\n  },\n  /**\n   * The default ES sorting method used for sorting the results.\n   *\n   * @param {Object} options\n   * @return array\n   */\n  'defaultSort' : function (options) {\n    return options.field;\n  }\n});\n\n// Expose ElasticSearch API\nEasySearch.ElasticSearch = ElasticSearch;\n"]}